import { Emitter } from '../../../emitter/emitter.js';
import { BaseAgent, AgentError } from '../../base.js';
import { AssistantMessage } from '../../../backend/message.js';
import { Client } from '@i-am-bee/acp-sdk/client/index.js';
import { shallowCopy } from '../../../serializer/utils.js';
import { NotImplementedError } from '../../../errors.js';
import { AgentRunProgressNotificationSchema } from '@i-am-bee/acp-sdk/types.js';
import { SSEClientTransport } from '@i-am-bee/acp-sdk/client/sse.js';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
class RemoteAgent extends BaseAgent {
  static {
    __name(this, "RemoteAgent");
  }
  input;
  emitter;
  constructor(input) {
    super(), this.input = input, this.emitter = Emitter.root.child({
      namespace: [
        "agent",
        "remote"
      ],
      creator: this
    });
  }
  async _run(input, _options, context) {
    const runner = this.createRunner(context);
    const output = await runner(input);
    const message = new AssistantMessage(output);
    return {
      message
    };
  }
  async listAgents() {
    const response = await this.input.client.listAgents();
    return response.agents;
  }
  createRunner(context) {
    return async (input) => {
      try {
        this.input.client.setNotificationHandler(AgentRunProgressNotificationSchema, async (notification) => {
          await context.emitter.emit("update", {
            output: JSON.stringify(notification.params.delta, null, 2)
          });
        });
        if (!this.input.client.transport) {
          await this.input.client.connect(this.input.transport);
        }
      } catch (e) {
        throw new AgentError(`Can't connect to Beeai Platform.`, [
          e
        ], {
          isFatal: true
        });
      }
      const agents = await this.listAgents();
      const agent = agents.find((agent2) => agent2.name === this.input.agentName);
      if (!agent) {
        throw new AgentError(`Agent ${this.input.agentName} is not registered in the platform`, [], {
          isFatal: true
        });
      }
      const response = await this.input.client.runAgent({
        name: this.input.agentName,
        input: typeof input.prompt === "string" ? {
          text: input.prompt
        } : input.prompt
      }, {
        timeout: 1e7,
        signal: context.signal,
        onprogress: /* @__PURE__ */ __name(() => null, "onprogress")
      });
      const output = JSON.stringify(response.output, null, 2);
      await context.emitter.emit("update", {
        output
      });
      return output;
    };
  }
  get memory() {
    throw new NotImplementedError();
  }
  set memory(memory) {
    throw new NotImplementedError();
  }
  createSnapshot() {
    return {
      ...super.createSnapshot(),
      input: shallowCopy(this.input),
      emitter: this.emitter
    };
  }
  static createSSEAgent(url, agentName) {
    return new RemoteAgent({
      client: new Client({
        name: "remote-agent",
        version: "1.0.0"
      }),
      transport: new SSEClientTransport(new URL(url)),
      agentName
    });
  }
}

export { RemoteAgent };
//# sourceMappingURL=agent.js.map
//# sourceMappingURL=agent.js.map